---
title: 'Open Source Contribution: TanStack Router (#4323, #5095)'
date: '2026-01-10'
tags: ['React', 'SSR', 'TanStack Router', 'Open Source']
---

## üëã Getting Started

I needed to implement Google login for an internal project. According to the [Google GSI documentation](https://developers.google.com/identity/gsi/web/guides/get-google-api-clientid?hl=en#load_the_client_library), I had to load their JavaScript library, and I thought using TanStack Router's `head` option would be perfect.

```javascript
export const Route = createFileRoute('/')(({
  head: () => ({{
    scripts: [
      {
        src: 'https://accounts.google.com/gsi/client',
        async: true,
        defer: true
      },
    ],
  }}),
}})
```

I expected it to work, but the login button never appeared. What was more confusing was the browser's dev tools response:

- Elements tab: `<script>` tag exists properly
- Network tab: No network request occurred

It failed silently without any error logs.

---

## ü§î Narrowing Down the Problem

First, I needed to figure out: "Is it my code or the library?"

I tried the simplest approach - adding the script tag directly to `index.html`.

```html
<!-- index.html -->
<script src="https://accounts.google.com/gsi/client" async defer></script>
```

This worked perfectly. The conclusion was clear:

**There's a constraint when dynamically rendering script tags in React components.**

---

## üîç Why Does React Block Scripts?

To cut to the chase, **React doesn't execute `<script>` tags inside components for security reasons.**

More precisely, it adds them to the DOM but prevents their execution.

When React creates a `<script>` tag, it doesn't directly call `document.createElement('script')`. Instead, it uses `innerHTML` to create it indirectly.

Scripts created this way get a 'parser-inserted' flag set by the browser, and according to the [HTML specification](https://html.spec.whatwg.org/multipage/scripting.html#script-processing-model), scripts with this flag are blocked from execution.

This is an **intentional design to prevent XSS attacks**. It blocks malicious scripts from executing when user input or external data is rendered in components.

You can see this mechanism clearly in React's source code:
https://github.com/facebook/react/blob/e41fd1fc0605dde41cff53e01039633c8e852b6d/packages/react-dom/src/client/ReactDOMComponent.js#L390-L408

```javascript
if (type === 'script') {
  // Use innerHTML to intentionally set the parser-inserted flag
  // and prevent script execution
  const div = ownerDocument.createElement('div');
  div.innerHTML = '<script><' + '/script>';
  const firstChild = ((div.firstChild: any): HTMLScriptElement);
  domElement = div.removeChild(firstChild);
}
```

As the comments indicate, React intentionally uses `innerHTML` to set the 'parser-inserted' flag and block script execution.

---

## üí° First Solution: Dynamic Script Injection

If React blocks scripts during rendering, we can **inject scripts dynamically after DOM mounting (Side Effect)**.

In typical React, this is done with the `useEffect` hook:
https://stackoverflow.com/questions/34424845/adding-script-tag-to-react-jsx

```javascript
useEffect(() => {
  const script = document.createElement('script');
  script.src = 'https://accounts.google.com/gsi/client';
  script.async = true;
  document.head.appendChild(script);

  // Remove script on component unmount
  return () => {
    document.head.removeChild(script);
  };
}, []);
```

Checking TanStack Router's [issue tracker](https://github.com/TanStack/router/issues/3687), I found many developers experiencing the same problem.

**The issue was that TanStack Router's `head` option was rendering script tags directly.** To support CSR environments, the implementation needed to change from directly rendering script tags to dynamically injecting them using `useEffect`.

### Starting Open Source Contribution

TanStack Router supports not only React but also other frameworks like Solid. I wrote generic logic to inject scripts according to each framework's lifecycle.

I submitted my work in [**PR #4323**](https://github.com/TanStack/router/pull/4323).

Since this was my first open source contribution, I wasn't proficient in writing test code or following guidelines, but I improved through communication with the maintainers.

---

## üö® Second Problem: Duplicate Execution in SSR

Shortly after the merge, a [new issue](https://github.com/TanStack/router/issues/4585) was reported.

**Scripts were being executed twice in SSR environments.**

### Why Twice?

In SSR environments, scripts get executed twice through this scenario:

1. HTML generated on the server includes `<script>` tag and is sent to the browser
2. Browser parses the HTML and executes the script (**first execution**)
3. After React hydration completes, the `useEffect` logic runs
4. `document.createElement('script')` creates and executes the same script again (**second execution**)

This caused serious side effects like Google Analytics collecting data twice or external widgets rendering duplicately.

### Sophisticated Duplicate Prevention Logic

Simply checking with `querySelector` wasn't enough.

Let's look at the logic implemented in [**PR #5095**](https://github.com/TanStack/router/pull/5095).

#### 1. Server Environment Check

```javascript
const router = useRouter();

// Don't perform duplicate checks in server environment since DOM doesn't exist
if (!router.isServer) {
  return null;
}
```

Since DOM doesn't exist during SSR, duplicate checks are only performed in client environments.

#### 2. External Script Duplicate Check

```javascript
if (attrs?.src && typeof attrs.src === 'string') {
  // URL normalization (relative path ‚Üí absolute path)
  const normSrc = (() => {
    try {
      const base = document.baseURI || window.location.href;
      return new URL(attrs.src, base).href;
    } catch {
      return attrs.src; // Return original if parsing fails
    }
  })();

  // Search only scripts with src attribute (performance optimization)
  const existingScript = Array.from(
    document.querySelectorAll('script[src]'),
  ).find((el) => (el as HTMLScriptElement).src === normSrc);

  if (existingScript) {
    return; // Don't render if already exists
  }
}
```

Key points:

- `querySelectorAll('script[src]')`: Performance optimization by searching only scripts with src attribute
- URL normalization: Convert relative paths like `./script.js`, `/script.js` to absolute URLs for accurate comparison
- try-catch handling: Safe processing even if URL parsing fails

#### 3. Inline Script Duplicate Check

```javascript
if (typeof children === 'string') {
  // Normalize type attribute
  const typeAttr =
    typeof attrs?.type === 'string' ? attrs.type : 'text/javascript';

  // Normalize nonce attribute
  const nonceAttr = typeof attrs?.nonce === 'string' ? attrs.nonce : undefined;

  // Search only inline scripts
  const existingScript = Array.from(
    document.querySelectorAll('script:not([src])'),
  ).find((el) => {
    if (!(el instanceof HTMLScriptElement)) return false;

    const sType = el.getAttribute('type') ?? 'text/javascript';
    const sNonce = el.getAttribute('nonce') ?? undefined;

    // Compare textContent, type, and nonce
    return (
      el.textContent === children && sType === typeAttr && sNonce === nonceAttr
    );
  });

  if (existingScript) {
    return; // Don't render if already exists
  }
}
```

For inline scripts, not just the content but also `type` and `nonce` attributes are compared. Even with identical content, different type or nonce means they're treated as separate scripts.

#### 4. Cleanup Logic

```javascript
React.useEffect(() => {
  const script = document.createElement('script');
  // ... script setup
  document.head.appendChild(script);

  // Remove script on route change
  return () => {
    document.head.removeChild(script);
  };
}, []);
```

Cleans up scripts only needed for specific pages during route navigation to prevent memory leaks.

#### 5. Adding Tests

The PR included E2E tests for these scenarios:

- Script duplicate prevention in SSR environment
- Duplicate prevention during client navigation
- Stability during multiple route transitions
- Inline script duplicate prevention

---

## ‚ú® Wrapping Up

Both PRs were merged and included **from TanStack Router v1.131.46 onwards**.

Checking the issues, at least 10+ developers were struggling with the same problem. Now they can use scripts with just the `head` option without any workarounds.

What I learned from this process:

**1. React's Design Philosophy**

I experienced firsthand through code that React prioritizes security over developer convenience. Even constraints that seem inconvenient are intentional designs to protect millions of users.

**2. Library Code Responsibility**

Code that works in your local environment is completely different from library code that must work in diverse environments worldwide. I had to consider all edge cases including SSR, hydration, and various framework environments.

**3. Attitude of Asking "Why"**

- "Why doesn't it work?" ‚Üí Identifying root causes
- "How can we solve this?" ‚Üí Setting the right direction
- "Is there a better way?" ‚Üí Continuous improvement

By repeatedly asking these questions, I moved beyond simple bug fixes to deeply understanding the framework.

What started as a small bug led to diving into React's internal mechanisms and contributing to open source, helping many developers. I want to continue growing as an engineer who constantly asks "Why" when facing problems.

---

**Related Links**:

- [TanStack Router Issue #3687](https://github.com/TanStack/router/issues/3687)
- [PR #4323: fix(react-router, solid-router): make head function scripts load properly](https://github.com/TanStack/router/pull/4323)
- [TanStack Router Issue #4585](https://github.com/TanStack/router/issues/4585)
- [PR #5095: fix(router): prevent script tag duplication in SSR and client-side navigation](https://github.com/TanStack/router/pull/5095)
